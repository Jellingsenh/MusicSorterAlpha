// Joshua Haynes
// Spotify music de-duplicator
// 22-26 October 2025
// Maven project, Java 21

package main;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.URI;
import java.net.URL;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Scanner;
import java.util.Set;

import org.json.JSONArray;
import org.json.JSONObject;
import org.json.JSONTokener;

public class MusicSorter {
	
	public static boolean askToUseCaches = true; // if false, automatically uses them
	public static boolean askToMakePlaylists = true; // if false, automatically makes them
	
	public static boolean logging = false; // show log statements
	public static boolean testingMode = false; // limits number of API calls to save time

	public static String authToken;
	public static String spotifyId;
	
	public final static String likedSongsFileName = "src/cache/likedSongs.txt";
	public final static String likedIdsFileName = "src/cache/likedIds.txt";
	public final static String unplayableSongsFileName = "src/cache/unplayableSongs.txt";
	public final static String duplicateSongsFileName = "src/cache/duplicateSongs.txt";
	public final static String unlikedSongsFileName = "src/cache/unlikedSongs.txt";
	public final static String playlistLocalSongsFileName = "src/cache/playlistLocalSongs.txt";
	public final static String playlistsFileName = "src/cache/playlists.txt";
	
	public static int retryCount;

	public static Map<String,Track> likedSongsMap;
	public static Set<String> likedSongsIdSet;
	public static boolean listFullyPopulated = false;
	
	public static Set<String> unplayableSongUrisSet;
	

	
	public static Set<String> duplicateSongUrisSet;
	
	public static int totalCount = 0;
	public static int likedCount = 0;
	public static int unplayableCount = 0;
	public static int duplicateCount = 0;
	public static int playlistsCount = 0;
	public static int unlikedCount = 0;
	public static int playlistsWithLocalTracksCount = 0;
	public static int localCount = 0;
	
	public static Set<Playlist> playlistsSet;
	public static Map<String,Set<String>> playlistLocalsMap;
	public static boolean playListIdsPopulated = false;
	
	public static Set<String> unlikedSongUrisSet;
	
	public static final String listDescription = "Auto generated by Music Sorter Alpha. EXCLUDE";
	
	public static final String newDuplicatePlaylistBaseName = "Duplicates from Liked Songs";
	public static final String newUnplayablePlaylistBaseName = "Unplayable Songs from Liked Songs";
	public static final String newLocalPlaylistBaseName = "Local Songs from Playlists";
	public static final String newUnlikedPlaylistBaseName = "Unliked Songs from Playlists";
	public static final int maxPlaylistSize = 9000;

	public static void main(String[] args) {
		retryCount = 0;
		
		likedSongsMap = new HashMap<String,Track>();
		likedSongsIdSet = new HashSet<String>();
		
		unplayableSongUrisSet = new HashSet<String>();
		
		duplicateSongUrisSet = new HashSet<String>();
		
		playlistsSet = new HashSet<Playlist>();
		playlistLocalsMap = new HashMap<String,Set<String>>();
		unlikedSongUrisSet = new HashSet<String>();
		
		System.out.println("~ Music Sorter Alpha ~\n");
		if (testingMode) {
			System.out.println("[Testing mode enabled]\n");
		}
		
		getProperties();
		
		Scanner input = new Scanner(System.in);
		
		// Get your liked songs, unplayable songs, & duplicate songs.

		if (likedCacheExists()) {
			if (askToUseCaches) {
				System.out.println("Songs cache found. Use it? (y/n): ");
			    String yesOrNo = input.next();
			    if (yesOrNo.equalsIgnoreCase("y")) {
			    	retrieveLikedSongsFromCache();
			    } else {
			    	populateLikedSongsList();
			    }
			} else {
				retrieveLikedSongsFromCache();
			}
		} else {
			populateLikedSongsList();
		}
		
		// Get unliked songs in your playlists
		
		if (playlistCacheExists()) {
			if (askToUseCaches) {
				System.out.println("\nPlaylists cache found. Use it? (y/n): ");
			    String yesOrNo = input.next();
			    if (yesOrNo.equalsIgnoreCase("y")) {
			    	retrievePlaylistsFromCache();
			    } else {
			    	getAllPlaylists();
			    }
			} else {
				retrievePlaylistsFromCache();
			}
		} else {
			getAllPlaylists();
		}
		
		if (unlikedCacheExists()) {
			if (askToUseCaches) {
				System.out.println("\nUnliked songs cache found. Use it? (y/n): ");
			    String yesOrNo = input.next();
			    if (yesOrNo.equalsIgnoreCase("y")) {
			    	retrieveUnlikedSongsFromCache();
			    } else {
			    	findUnlikedPlaylistTracks();
			    }
			} else {
				retrieveUnlikedSongsFromCache();
			}
		} else {
			findUnlikedPlaylistTracks();
		}
		
		if (logging) {
			System.out.println("Total songs (from your liked songs): " + totalCount);
			System.out.println("Liked songs: " + likedCount);
			System.out.println("Unplayable songs: " + unplayableCount);
			System.out.println("Duplicate songs: " + duplicateCount);
			
			System.out.println("Playlists: " + playlistsCount);
			System.out.println("Unliked songs: " + unlikedCount);
			System.out.println("Playlists with local tracks: " + playlistsWithLocalTracksCount);
			System.out.println("Local songs: " + localCount);
		}
		
		// create new playlists (size max 9,000)
		if (askToMakePlaylists) {
			System.out.println("\nCreate new playlists? (y/n): ");
		    String yesOrNo = input.next();
		    if (yesOrNo.equalsIgnoreCase("y")) {
		    	makePlaylists();
		    } else {
		    	displayLocalTrackInfo();
		    }
		} else {
			makePlaylists();
		}
		
		input.close();
		
		System.out.println("\n~ Fin ~");
	}
	
	// Properties & Authorization function:
	
	private static void getProperties() {
		try {
			Properties prop = new Properties();
			prop.load(new FileInputStream("src/application.properties"));
			authToken = prop.getProperty("authToken");
			spotifyId = prop.getProperty("spotifyId");
		} catch (Exception e) {
			System.out.println("Error reading properties: " + e.getMessage());
		}
	}
	
	// Cache exists functions:
	
	public static boolean likedCacheExists() {
		File f = new File(likedSongsFileName);
		if(f.exists() && !f.isDirectory()) { 
		    return true;
		} else {
			return false;
		}
	}
	
	public static boolean playlistCacheExists() {
		File f = new File(playlistsFileName);
		if(f.exists() && !f.isDirectory()) { 
		    return true;
		} else {
			return false;
		}
	}
	
	public static boolean unlikedCacheExists() {
		File f = new File(unlikedSongsFileName);
		if(f.exists() && !f.isDirectory()) { 
		    return true;
		} else {
			return false;
		}
	}
	
	// Cache data functions:
	
	public static void cacheLikedSongs() {
		ObjectOutputStream oos = null;
		ObjectOutputStream oos2 = null;
		ObjectOutputStream oos3 = null;
		ObjectOutputStream oos4 = null;
		
		System.out.println("Caching ...");
		
		try{
			oos2 = new ObjectOutputStream(new FileOutputStream(likedIdsFileName));
		    oos2.writeObject(likedSongsIdSet);
		    System.out.println(likedSongsIdSet.size() + " song ids cached.");
		    
		    oos = new ObjectOutputStream(new FileOutputStream(likedSongsFileName));
		    oos.writeObject(likedSongsMap);
		    System.out.println(likedSongsMap.size() + " liked songs cached.");
		    
		    oos3 = new ObjectOutputStream(new FileOutputStream(unplayableSongsFileName));
		    oos3.writeObject(unplayableSongUrisSet);
		    System.out.println(unplayableSongUrisSet.size() + " unplayable songs cached.");
		    
		    oos4 = new ObjectOutputStream(new FileOutputStream(duplicateSongsFileName));
		    oos4.writeObject(duplicateSongUrisSet);
		    System.out.println(duplicateSongUrisSet.size() + " duplicate songs cached.");
		} catch (Exception ex) {
		    ex.printStackTrace();
		} finally {
		    if(oos != null){
		        try {
					oos.close();
				} catch (Exception e) {
					e.printStackTrace();
				}
		    } 
		    if(oos2 != null){
		        try {
					oos2.close();
				} catch (Exception e) {
					e.printStackTrace();
				}
		    } 
		    if(oos3 != null){
		        try {
					oos3.close();
				} catch (Exception e) {
					e.printStackTrace();
				}
		    } 
		    if(oos4 != null){
		        try {
					oos4.close();
				} catch (Exception e) {
					e.printStackTrace();
				}
		    } 
		}
	}
	
	public static void cachePlaylists() {
		ObjectOutputStream oos = null;
		FileOutputStream fout = null;
		
		System.out.println("Caching ...");
		
		try{
		    fout = new FileOutputStream(playlistsFileName);
		    oos = new ObjectOutputStream(fout);
		    oos.writeObject(playlistsSet);
		    System.out.println(playlistsSet.size() + " playlists cached.");
		} catch (Exception ex) {
		    ex.printStackTrace();
		} finally {
		    if(oos != null){
		        try {
					oos.close();
				} catch (Exception e) {
					e.printStackTrace();
				}
		    } 
		}
	}
	
	public static void cacheUnlikedSongs() {
		ObjectOutputStream oos = null;
		ObjectOutputStream oos2 = null;
		
		System.out.println("Caching ...");
		
		try{
		    oos = new ObjectOutputStream(new FileOutputStream(unlikedSongsFileName));
		    oos.writeObject(unlikedSongUrisSet);
		    System.out.println(unlikedSongUrisSet.size() + " unliked songs cached.");
		    
		    oos2 = new ObjectOutputStream(new FileOutputStream(playlistLocalSongsFileName));
		    oos2.writeObject(playlistLocalsMap);
		    System.out.println(playlistLocalsMap.size() + " playlists containing local songs, with a total of " + localCount + " local songs cached."); 
		} catch (Exception ex) {
		    ex.printStackTrace();
		} finally {
		    if(oos != null){
		        try {
					oos.close();
				} catch (Exception e) {
					e.printStackTrace();
				}
		    } 
		    if(oos2 != null){
		        try {
					oos2.close();
				} catch (Exception e) {
					e.printStackTrace();
				}
		    } 
		}
	}
	
	// Retrieve from cache functions:
	
	public static void retrieveLikedSongsFromCache() {
		ObjectInputStream objectinputstream = null;
		ObjectInputStream objectinputstream2 = null;
		ObjectInputStream objectinputstream3 = null;
		ObjectInputStream objectinputstream4 = null;
		
		System.out.println("\nRetrieving from cache ...");
		
		try {
			objectinputstream4 = new ObjectInputStream(new FileInputStream(likedIdsFileName));
		    likedSongsIdSet = (Set<String>) objectinputstream4.readObject();
		    System.out.println("Loaded " + likedSongsIdSet.size() + " song ids from the cache."); 
		    
		    objectinputstream = new ObjectInputStream(new FileInputStream(likedSongsFileName));
		    likedSongsMap = (Map<String,Track>) objectinputstream.readObject();
		    System.out.println("Loaded " + likedSongsMap.size() + " liked songs from the cache."); 
		    
		    objectinputstream3 = new ObjectInputStream(new FileInputStream(unplayableSongsFileName));
		    unplayableSongUrisSet = (Set<String>) objectinputstream3.readObject();
		    System.out.println("Loaded " + unplayableSongUrisSet.size()+" unplayable songs from the cache.");

		    objectinputstream2 = new ObjectInputStream(new FileInputStream(duplicateSongsFileName));
		    duplicateSongUrisSet = (Set<String>) objectinputstream2.readObject();
		    System.out.println("Loaded " + duplicateSongUrisSet.size()+" duplicate songs from the cache.");  
		} catch (Exception e) {
		    e.printStackTrace();
		} finally {
		    if(objectinputstream != null){
		        try {
					objectinputstream .close();
				} catch (IOException e) {
					e.printStackTrace();
				}
		    } 
		    if(objectinputstream2 != null){
		        try {
					objectinputstream2 .close();
				} catch (IOException e) {
					e.printStackTrace();
				}
		    } 
		    if(objectinputstream3 != null){
		        try {
					objectinputstream3 .close();
				} catch (IOException e) {
					e.printStackTrace();
				}
		    } 
		    if(objectinputstream4 != null){
		        try {
					objectinputstream4 .close();
				} catch (IOException e) {
					e.printStackTrace();
				}
		    } 
		}
	}
	
	public static void retrievePlaylistsFromCache() {
		ObjectInputStream objectinputstream = null;
		
		System.out.println("\nRetrieving from cache ...");
		
		try {
		    FileInputStream streamIn = new FileInputStream(playlistsFileName);
		    objectinputstream = new ObjectInputStream(streamIn);
		    playlistsSet = (Set<Playlist>) objectinputstream.readObject();
		    System.out.println("Loaded " + playlistsSet.size() + " playlists from the cache."); 
		} catch (Exception e) {
		    e.printStackTrace();
		} finally {
		    if(objectinputstream != null){
		        try {
					objectinputstream .close();
				} catch (IOException e) {
					e.printStackTrace();
				}
		    } 
		}
	}
	
	public static void retrieveUnlikedSongsFromCache() {
		ObjectInputStream objectinputstream = null;
		ObjectInputStream objectinputstream2 = null;
		
		System.out.println("\nRetrieving from cache ...");
		
		try {
		    objectinputstream = new ObjectInputStream(new FileInputStream(unlikedSongsFileName));
		    unlikedSongUrisSet = (Set<String>) objectinputstream.readObject();
		    System.out.println("Loaded " + unlikedSongUrisSet.size() + " unliked songs from the cache."); 
		    
		    objectinputstream2 = new ObjectInputStream(new FileInputStream(playlistLocalSongsFileName));
		    playlistLocalsMap = (Map<String, Set<String>>) objectinputstream2.readObject();
		    for (Set<String> localsSet : playlistLocalsMap.values()) {
		    		localCount += localsSet.size();
		    }
		    System.out.println("Loaded " + playlistLocalsMap.size() + " playlists containing local songs, with a total of " + localCount +" local songs from the cache."); 
		} catch (Exception e) {
		    e.printStackTrace();
		} finally {
		    if(objectinputstream != null){
		        try {
					objectinputstream.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
		    } 
		    if(objectinputstream2 != null){
		        try {
					objectinputstream2.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
		    } 
		}
	}

	// Liked & unplayable songs functions:
	
	public static void populateLikedSongsList() {
		try {
			System.out.print("Getting liked songs from Spotify");
			int offset = 0;
			while (!listFullyPopulated) {
				getLikedSongs(offset);
				offset += 50;
				if (Math.random() < .8) { System.out.print("."); } // 80% chance
				if (testingMode && offset > 1000) { listFullyPopulated = true; }
			}
			System.out.println("done.\n");
			
			scanListForDuplicates();
			
			cacheLikedSongs();
		} catch (Exception e) {
			System.out.println("\nError getting liked songs from Spotify: " + e.getMessage());
		}
	}
	
	public static void getLikedSongs(int offset) throws Exception {		
		URI uri = new URI("https://api.spotify.com/v1/me/tracks?limit=50&offset=" + offset);
		URL url = uri.toURL();
							
		HttpURLConnection conn = (HttpURLConnection) url.openConnection();
		conn.setRequestMethod("GET");
		conn.setRequestProperty("Authorization", "Bearer " + authToken);
		conn.connect();

		int responsecode = conn.getResponseCode();
		
		if (responsecode != 200) {
			if (retryCount > 3) {
				retryCount = 0;
				throw new RuntimeException("(retried 3 times) HttpResponseCode: " + responsecode);
			}
			System.out.print("HttpResponseCode: " + responsecode + ", retrying getLikedSongs()...");
			retryCount += 1;
			getLikedSongs(offset); // retry recursively
		} else {
			retryCount = 0;
			
			JSONObject likedSongsJSON = new JSONObject(new JSONTokener(conn.getInputStream())); 
			JSONArray tempLikedSongsArray = likedSongsJSON.getJSONArray("items");
						
			if (tempLikedSongsArray.length() < 1) {
				listFullyPopulated = true;
				return;
			} else {
				
				for (int i = 0; i < tempLikedSongsArray.length(); i++ ) {
					JSONObject trackJSON_ = (JSONObject) tempLikedSongsArray.get(i);
					JSONObject trackJSON = (JSONObject) trackJSON_.getJSONObject("track");
					
					Track tempTrack = new Track();
					tempTrack.setName(trackJSON.getString("name"));
					tempTrack.setTrackId(trackJSON.getString("id"));
					tempTrack.setDuration(trackJSON.getInt("duration_ms"));
					tempTrack.setPlayable(trackJSON.getBoolean("is_playable"));
					tempTrack.setLocal(trackJSON.getBoolean("is_local"));
					tempTrack.setUri(trackJSON.getString("uri"));
					
					JSONArray tempArtistsArray = trackJSON.getJSONArray("artists");
					List<String> tempArtists = new ArrayList<String>();
					for (int j = 0; j < tempArtistsArray.length(); j++ ) {
						JSONObject artistJSON = (JSONObject) tempArtistsArray.getJSONObject(j);
						tempArtists.add(artistJSON.getString("name"));
					}
					tempTrack.setArtists(tempArtists);
					
					// add Track to sets
					totalCount += 1;
				
					if (!likedSongsIdSet.contains(tempTrack.getTrackId())) {
						likedSongsIdSet.add(tempTrack.getTrackId());
					}
					
					if (!tempTrack.isPlayable()) { 
						if (!unplayableSongUrisSet.contains(tempTrack.getUri())) {
							unplayableCount += 1;
							unplayableSongUrisSet.add(tempTrack.getUri());
							if (logging) { 
								System.out.print("\nunplayable song "+tempTrack.getName()+" ("+tempTrack.getUri()+") found."); 
								System.out.print("\nunplayable songs size: " + unplayableSongUrisSet.size());
							}
						}
					}
					
					if (likedSongsMap.containsKey(tempTrack.getName())) {
						if (!duplicateSongUrisSet.contains(tempTrack.getUri())) {
							duplicateCount += 1;
							duplicateSongUrisSet.add(tempTrack.getUri());
						} 
						Track temp0 = likedSongsMap.get(tempTrack.getName());
						if (!duplicateSongUrisSet.contains(temp0.getUri())) {
							duplicateCount += 1;
							duplicateSongUrisSet.add(temp0.getUri());
						} 
					} else {
						likedCount += 1;
						likedSongsMap.put(tempTrack.getName(), tempTrack);
					}
				}
			}		
		}
		return;
	}
	
	// Duplicate songs functions:
	
	public static void scanListForDuplicates() { // O(n^2)
		System.out.print("Scanning for duplicates");
		
		List<String> songNameList = new ArrayList<String>(likedSongsMap.keySet()); 
		
		for (int b = 0; b < songNameList.size(); b++) {
			if (Math.random() < .05) { System.out.print("."); } // 5% chance
			getTrackDuplicates(songNameList, b);
		}
		
		System.out.println("done.\n");
	}
	
	public static void getTrackDuplicates(List<String> songNameList,  int startIndex) {
		String currentTrackName = songNameList.get(startIndex);
		
		if (!currentTrackName.contains("(")) { // no features, name is normal
			return;
		}
		
		for (int c = startIndex+1; c < songNameList.size(); c++) {
			String nextTrackName = songNameList.get(c);
			if (compareWithoutFeatures(currentTrackName, nextTrackName)) {
				Track temp1 = likedSongsMap.get(currentTrackName);
				if (!duplicateSongUrisSet.contains(temp1.getUri())) {
					duplicateCount += 1;
					duplicateSongUrisSet.add(temp1.getUri());
				} 
				Track temp2 = likedSongsMap.get(nextTrackName);
				if (!duplicateSongUrisSet.contains(temp2.getUri())) {
					duplicateCount += 1;
					duplicateSongUrisSet.add(temp2.getUri());
				} 
			}
		}
	}
	
	public static boolean compareWithoutFeatures(String s1, String s2) {
		String split1 = s1.split("\\s\\(")[0];
		String split2 = s2.split("\\s\\(")[0];
	
		if (split1.equals(split2)) {			
			if (likedSongsMap.get(s1).getArtists().equals(likedSongsMap.get(s2).getArtists())) {
				if (logging) { System.out.println("\n[" + s1 + " found to be similar to " + s2 + "]"); }
				return true;
			}
		}
		
		return false;
	}
	
	// Get playlist functions:
	
	public static void getAllPlaylists() {
		System.out.print("\nGetting your playlists from Spotify (excludes any playlist with EXCLUDE in the description)");
		
		try {
			int offsetB = 0;
			while (!playListIdsPopulated) {
				getPlaylistIds(offsetB);
				offsetB += 50;
				if (Math.random() < .8) { System.out.print("."); } // 80% chance
			}
			System.out.println("done.\n");
			cachePlaylists();
		} catch (Exception e) {
			System.out.println("\nError getting your playlists from Spotify: " + e.getMessage());
		}
	}
	
	public static void getPlaylistIds(int offset) throws Exception {
		URI uri = new URI("https://api.spotify.com/v1/me/playlists?limit=50&offset=" + offset);
		URL url = uri.toURL();
							
		HttpURLConnection conn = (HttpURLConnection) url.openConnection();
		conn.setRequestMethod("GET");
		conn.setRequestProperty("Authorization", "Bearer " + authToken);
		conn.connect();

		int responsecode = conn.getResponseCode();
		
		if (responsecode != 200) {
			if (retryCount > 3) {
				retryCount = 0;
				throw new RuntimeException("(retried 3 times) HttpResponseCode: " + responsecode);
			}
			System.out.print("HttpResponseCode: " + responsecode + ", retrying getPlaylistIds()...");
			retryCount += 1;
			getPlaylistIds(offset); // retry recursively
		} else {
			retryCount = 0;
			JSONObject playlistsJSON = new JSONObject(new JSONTokener(conn.getInputStream()));
			JSONArray tempPlaylistsArray = playlistsJSON.getJSONArray("items");
			
			if (tempPlaylistsArray.length() < 1) {
				playListIdsPopulated = true;
				return;
			} else {
				for (int c = 0; c < tempPlaylistsArray.length(); c++) {
					JSONObject playlistJSON = (JSONObject) tempPlaylistsArray.get(c);
				
					if (playlistJSON.getJSONObject("owner").getString("id").equals(spotifyId) && 
							!playlistJSON.getString("description").contains("EXCLUDE")) {
						playlistsCount += 1;
						playlistsSet.add(new Playlist(playlistJSON.getString("name"),playlistJSON.getString("id")));
					} 
				}	
			}
		}
	}
	
	// Unliked songs functions:
	
	public static void findUnlikedPlaylistTracks()  {
		System.out.print("\nGetting unliked songs from all your Spotify playlists");
		
		try {		
			if (playlistsSet.size() < 1) {
				throw new Exception("No playlists found.");
			}
			
			if (likedSongsIdSet.size() < 1) {
				throw new Exception("No likes found.");
			}
			
			for (Playlist P : playlistsSet) {
				getUnlikedSongsFromPlaylist(P);
			}
			System.out.println("done.\n");
			
			cacheUnlikedSongs();
		} catch (Exception e) {
			System.out.println("\nError getting songs from Spotify playlists: " + e.getMessage());
		}
	}
	
	public static void  getUnlikedSongsFromPlaylist(Playlist P) throws Exception {
		String pQuery = "https://api.spotify.com/v1/playlists/"+P.getId()+"/tracks?limit=50&offset=";
		boolean playlistCompleted = false;
		int offsetC = 0;
		
		Set<String> localsForP = new HashSet<String>();
		
		while (!playlistCompleted) {
			
			URI uri = new URI(pQuery + offsetC);
			URL url = uri.toURL();
								
			HttpURLConnection conn = (HttpURLConnection) url.openConnection();
			conn.setRequestMethod("GET");
			conn.setRequestProperty("Authorization", "Bearer " + authToken);
			conn.connect();

			int responsecode = conn.getResponseCode();
			
			if (responsecode != 200) {
				if (retryCount > 3) {
					retryCount = 0;
					throw new RuntimeException("(retried 3 times) HttpResponseCode: " + responsecode);
				}
				System.out.print("HttpResponseCode: " + responsecode + ", retrying getUnlikedSongsFromPlaylist()...");
				retryCount += 1;
				offsetC -= 50; // retry recursively
			} else {
				retryCount = 0;
				JSONObject playlistSongsJSON = new JSONObject(new JSONTokener(conn.getInputStream())); 
				JSONArray tempPlaylistSongsArray = playlistSongsJSON.getJSONArray("items");
							
				if (tempPlaylistSongsArray.length() < 1) {
					playlistCompleted = true;
					if (localsForP.size() > 0) { 
						playlistsWithLocalTracksCount += 1;
						playlistLocalsMap.put(P.getName(), localsForP); 
						if (logging) {
							System.out.println("Adding playlist " + P.getName() + " to the playlist map (size = "+playlistLocalsMap.size()+") with " + localsForP.size() + " local songs.");
						}
					} else {
						if (logging) {
							System.out.println("Not adding playlist " + P.getName() + " to the playlist map (no local songs).");
						}
					}
					return;
				} else {

					for (int i = 0; i < tempPlaylistSongsArray.length(); i++ ) {
						JSONObject playSongJSON_ = (JSONObject) tempPlaylistSongsArray.get(i);
						JSONObject playSongJSON = (JSONObject) playSongJSON_.getJSONObject("track");
												
						Track tempTrackB = new Track();
						tempTrackB.setName(playSongJSON.getString("name"));
						tempTrackB.setDuration(playSongJSON.getInt("duration_ms"));
						tempTrackB.setPlayable(true); // (playSongJSON.getBoolean("is_playable"));
						tempTrackB.setUri(playSongJSON.getString("uri"));
						tempTrackB.setLocal(playSongJSON.getBoolean("is_local"));
						if (!tempTrackB.isLocal()) { 
							tempTrackB.setTrackId(playSongJSON.getString("id"));  
						}
						
						JSONArray tempPlayArtistsArray = playSongJSON.getJSONArray("artists");
						List<String> tempPlayArtists = new ArrayList<String>();
						for (int j = 0; j < tempPlayArtistsArray.length(); j++ ) {
							JSONObject artistPlayJSON = (JSONObject) tempPlayArtistsArray.getJSONObject(j);
							tempPlayArtists.add(artistPlayJSON.getString("name"));
						}
						tempTrackB.setArtists(tempPlayArtists);
						
						if (tempTrackB.isLocal()) {
							if (!localsForP.contains(tempTrackB.getName())) {
								localCount += 1;
								localsForP.add(tempTrackB.getName());
								if (logging) { 
									System.out.print("\nlocal song "+tempTrackB.getName()+" ("+tempTrackB.getUri()+") found in playlist "+P.getName()+"."); 
									System.out.print("\nlocal songs size: " + localCount);
								}
							}
						} else if (!likedSongsIdSet.contains(tempTrackB.getTrackId())) { // not in liked
							if (!unlikedSongUrisSet.contains(tempTrackB.getUri())) {
								unlikedCount += 1;
								unlikedSongUrisSet.add(tempTrackB.getUri());
								if (logging) { 
									System.out.print("\nunliked song "+tempTrackB.getName()+" ("+tempTrackB.getUri()+") found in playlist "+P.getName()+"."); 
									System.out.print("\nunliked songs size: " + unlikedSongUrisSet.size());
								}
							}
						}
					}
				}
			}
			offsetC += 50;
			if (Math.random() < .5) { System.out.print("."); } // 50% chance
			if (testingMode) { playlistCompleted = true; }
		}
	}
	
	// Create & populate playlists functions:
	
	private static void makePlaylists() {
		System.out.println("\nCreating & populating playlists...");
		addDuplicatesToPlaylist();
		addUnplayablesToPlaylist();
		addUnlikedPlaylistTracksToPlaylist();
//		addLocalPlaylistTracksToPlaylist(); // cannot add local files via web API
		displayLocalTrackInfo();
	}
	
	public static void addDuplicatesToPlaylist() {
		String newDupeName = newDuplicatePlaylistBaseName + " [MSA " + generateRandomString() + "]";
		System.out.println("Creating playlist "+newDupeName+"...");
		
		createAndPopulatePlaylistRecursively(newDupeName, duplicateSongUrisSet, "duplicate");
	}
	
	public static void addUnplayablesToPlaylist() {
		String newUnplayName = newUnplayablePlaylistBaseName + " [MSA " + generateRandomString() + "]";
		System.out.println("Creating playlist "+newUnplayName+"...");
		
		createAndPopulatePlaylistRecursively(newUnplayName, unplayableSongUrisSet, "unplayable");
	}
	
	public static void addUnlikedPlaylistTracksToPlaylist() {
		String newUnlikeName = newUnlikedPlaylistBaseName + " [MSA " + generateRandomString() + "]";
		System.out.println("Creating playlist "+newUnlikeName+"...");
		
		createAndPopulatePlaylistRecursively(newUnlikeName, unlikedSongUrisSet, "unliked");
	}
	
	private static String generateRandomString() {
		String AlphaNumericString = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvxyz!@#$%^&*.?";

		StringBuilder result = new StringBuilder();
		for (int r = 0; r < 6; r++) {
			result.append(AlphaNumericString.charAt((int) (Math.random() * AlphaNumericString.length())));
		}
		
		return result.toString();
	}
	
	private static void createAndPopulatePlaylistRecursively(String playlistName, Set<String> trackUrisSet, String type) {
		if (trackUrisSet.size() < 1) {
			System.out.println("Did not create playlist " + playlistName + " (no " + type + " songs found).");
			return;
		}
		
		if (trackUrisSet.size() <= maxPlaylistSize) {
			try {
				String pId = createMSAPlaylist(playlistName);
				if (logging) { System.out.println("Adding "+trackUrisSet.size()+" " + type + " songs to " + playlistName); }
				addSongsToPlaylist100AtATime(pId, trackUrisSet);
			} catch (Exception e) {
				e.printStackTrace();
			}
		} else {
			for (Set<String> halfSet : splitSetInHalf(trackUrisSet) ) {
				String newName = playlistName.substring(0, playlistName.length()-1) + "-" + generateRandomString() + "]";
				createAndPopulatePlaylistRecursively(newName, halfSet, type);
			}
		}
	}
	
	private static Set<Set<String>> splitSetInHalf(Set<String> inSet) {
		Set<Set<String>> outSets = new HashSet<Set<String>>();
		int halfway = inSet.size() / 2;
		
		Set<String> firstHalf = new HashSet<String>();
		Set<String> secondHalf = new HashSet<String>();
		
		boolean inFirst = true;
		int setCount = 0;
		for (String s : inSet) {
			if (inFirst) { // 1st half
				firstHalf.add(s);
			} else { // 2nd half
				secondHalf.add(s);
			}
			
			if (setCount >= halfway) {
				inFirst = false;
			}
			setCount += 1;
		}
		
		outSets.add(firstHalf);
		outSets.add(secondHalf);
		return outSets;
	}
	
	public static void displayLocalTrackInfo() {
		System.out.println("\nLocal tracks (must be added to playlists manually):");
		 
		for (String playlistName : playlistLocalsMap.keySet()) {
			Set<String> localNameSet = playlistLocalsMap.get(playlistName);
			if (localNameSet.size() > 0) {
				System.out.println("\n  ======>  Playlist: " + playlistName + "  <======  ");
				System.out.println("{");
				for (String localName : localNameSet) {
					System.out.println(localName);
				}
				System.out.println("}");
			}
	    }
	}
	
	private static String createMSAPlaylist(String title) throws Exception {
		URI uri = new URI("https://api.spotify.com/v1/users/"+spotifyId+"/playlists");
		URL url = uri.toURL();
							
		HttpURLConnection conn = (HttpURLConnection) url.openConnection();
		conn.setRequestMethod("POST");
		conn.setRequestProperty("Authorization", "Bearer " + authToken);
		conn.setRequestProperty("Content-Type", "application/json");
		conn.setRequestProperty("Accept", "application/json");
		conn.setDoOutput(true);
		String jsonInputString = "{\"name\": \""+title+"\", \"description\": \""+listDescription+"\",\"public\":false}";
	
		try(OutputStream os = conn.getOutputStream()) {
		    byte[] inputBytes = jsonInputString.getBytes("utf-8");
		    os.write(inputBytes, 0, inputBytes.length);			
		}
		
		conn.connect();

		int responsecode = conn.getResponseCode();
		
		if (responsecode > 201) {
		    throw new RuntimeException("HttpResponseCode: " + responsecode);
		} else {
			JSONObject playlistIdJSON = new JSONObject(new JSONTokener(conn.getInputStream())); 
			System.out.println("Created playlist successfully.");
			return playlistIdJSON.getString("id");
		}
	}
	
	private static void addSongsToPlaylist100AtATime(String playlistId, Set<String> songUris) throws Exception {
		Set<Set<String>> UriSetsOf100 = new HashSet<Set<String>>();
		Set<String> tempUriSet = new HashSet<String>();
						
		int count = 0;
		for (String songUri : songUris) {
			count += 1;
			tempUriSet.add(songUri);
			if (count > 99) {
				UriSetsOf100.add(tempUriSet);
				tempUriSet = new HashSet<String>();
				count = 0;
			}
		}
		
		if (tempUriSet.size() > 0) {
			UriSetsOf100.add(tempUriSet);
		}
		
		for (Set<String> uriSetOf100 : UriSetsOf100) {
			addSongsToPlaylist(playlistId, uriSetOf100);
			if (Math.random() < .8) { System.out.print("."); } // 80% chance
		}
		System.out.println("done.");
	}
	
	private static void addSongsToPlaylist(String playlistId, Set<String> songUris) throws Exception {
		URI uri = new URI("https://api.spotify.com/v1/playlists/"+playlistId+"/tracks");
		URL url = uri.toURL();
							
		HttpURLConnection conn = (HttpURLConnection) url.openConnection();
		conn.setRequestMethod("POST");
		conn.setRequestProperty("Authorization", "Bearer " + authToken);
		conn.setRequestProperty("Content-Type", "application/json");
		conn.setRequestProperty("Accept", "application/json");
		conn.setDoOutput(true);
		
		String jsonInputString = createJsonFromUriSet(songUris);
		
		if (logging) {
			System.out.println("\nUris in Json format: \n" + jsonInputString + "\n");
		}
	
		try(OutputStream os = conn.getOutputStream()) {
		    byte[] inputBytes = jsonInputString.getBytes("utf-8");
		    os.write(inputBytes, 0, inputBytes.length);			
		}
		
		conn.connect();

		int responsecode = conn.getResponseCode();
		
		if (responsecode > 201) {
			if (retryCount > 3) {
				retryCount = 0;
				throw new RuntimeException("(retried 3 times) HttpResponseCode: " + responsecode);
			}
			System.out.print("HttpResponseCode: " + responsecode + ", retrying addSongsToPlaylist()...");
			retryCount += 1;
			addSongsToPlaylist(playlistId, songUris); // retry recursively
		} else {
			if (Math.random() < .8) { System.out.print("."); } // 80% chance
		}
	}
	
	private static String createJsonFromUriSet(Set<String> uriSet) {
		String JsonUris = "{\"uris\": [\"";
		String betweenJson = "\",\"";
		String endJson = "\"]}";
		
		for (String uri : uriSet) {
			JsonUris = JsonUris + uri + betweenJson;
		}
		JsonUris = JsonUris.substring(0, JsonUris.length()-betweenJson.length()) + endJson;	
		
		return JsonUris;
	}
}
